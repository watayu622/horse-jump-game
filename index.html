<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>È¶¨„Ç∏„É£„É≥„Éó„Ç≤„Éº„É† üê¥üóªü¶ÖüçÜ</title>
    <meta property="og:title" content="È¶¨„Ç∏„É£„É≥„Éó„Ç≤„Éº„É† üê¥üóªü¶ÖüçÜ">
    <meta property="og:description" content="‰∏ÄÂØåÂ£´‰∫åÈ∑π‰∏âËåÑÂ≠ê„ÇíÈ£õ„Å≥Ë∂ä„Åà„ÇçÔºÅ„Çø„ÉÉ„Éó„Åß„Ç∏„É£„É≥„ÉóÔºÅ">
    <meta property="og:type" content="website">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#87CEEB">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; background: #87CEEB; font-family: 'Segoe UI', sans-serif; touch-action: manipulation; -webkit-user-select: none; user-select: none; }
        #gameCanvas { display: block; position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
        .ui-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .score-board { position: absolute; top: max(8px, env(safe-area-inset-top)); left: 50%; transform: translateX(-50%); display: flex; gap: 15px; padding: 6px 16px; background: rgba(255,255,255,0.9); border-radius: 20px; font-size: 14px; font-weight: bold; color: #333; box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        .high-score { color: #e74c3c; }
        .overlay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: rgba(255,255,255,0.95); padding: 20px; border-radius: 20px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); z-index: 200; pointer-events: auto; max-width: 95%; max-height: 90%; overflow-y: auto; }
        .overlay.hidden { display: none; }
        .overlay h1 { font-size: 20px; margin-bottom: 8px; color: #333; }
        .overlay p { font-size: 14px; margin-bottom: 6px; color: #666; }
        .overlay .emoji { font-size: 36px; margin-bottom: 8px; }
        .start-btn { padding: 10px 30px; font-size: 16px; background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; border-radius: 25px; cursor: pointer; margin-top: 6px; }
        .instructions { margin-top: 10px; padding: 8px; background: #f0f0f0; border-radius: 10px; font-size: 11px; color: #555; text-align: left; }
        .instructions .score-info { margin-top: 6px; display: flex; flex-wrap: wrap; gap: 8px; }
        .share-section { margin-top: 10px; padding-top: 10px; border-top: 1px solid #ddd; }
        .share-btn { display: inline-flex; align-items: center; gap: 6px; padding: 8px 16px; font-size: 13px; background: #06C755; color: white; border: none; border-radius: 18px; text-decoration: none; }
        .share-btn svg { width: 18px; height: 18px; }
        .fullscreen-btn { position: absolute; top: max(8px, env(safe-area-inset-top)); right: max(8px, env(safe-area-inset-right)); padding: 6px 10px; background: rgba(0,0,0,0.6); color: white; border: none; border-radius: 8px; font-size: 12px; z-index: 100; pointer-events: auto; display: none; }
        @media (hover: hover) and (pointer: fine) { .fullscreen-btn { display: flex; align-items: center; gap: 4px; } }
        @media (max-height: 450px) { .overlay { padding: 12px 20px; display: flex; flex-wrap: wrap; align-items: center; justify-content: center; gap: 10px; } .overlay .emoji { font-size: 28px; margin: 0; } .overlay h1 { font-size: 18px; margin: 0; } .overlay p { font-size: 13px; margin: 0 8px; } .overlay .start-btn { padding: 8px 20px; font-size: 14px; margin: 0; } .overlay .instructions { display: none; } .overlay .share-section { margin: 0; padding: 0; border: none; } .score-board { padding: 4px 12px; font-size: 12px; gap: 10px; } }
        @media (max-height: 350px) { .overlay { padding: 8px 15px; } .overlay .emoji { font-size: 24px; } .overlay h1 { font-size: 16px; } .overlay .share-section { display: none; } }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="ui-layer">
        <div class="score-board"><span>„Çπ„Ç≥„Ç¢: <span id="current-score">0</span></span><span>„Éè„Ç§„Çπ„Ç≥„Ç¢: <span id="high-score" class="high-score">0</span></span></div>
        <button class="fullscreen-btn" onclick="toggleFullscreen()"><span id="fullscreenText">ÂÖ®ÁîªÈù¢</span></button>
        <div class="overlay" id="startOverlay">
            <div class="emoji">üê¥üóªü¶ÖüçÜ</div>
            <h1>È¶¨„Ç∏„É£„É≥„Éó„Ç≤„Éº„É†</h1>
            <p>‰∏ÄÂØåÂ£´‰∫åÈ∑π‰∏âËåÑÂ≠ê„ÇíÈ£õ„Å≥Ë∂ä„Åà„ÇçÔºÅ</p>
            <button class="start-btn" onclick="startGame()">„Ç≤„Éº„É†„Çπ„Çø„Éº„Éà</button>
            <div class="instructions"><strong>Êìç‰Ωú:</strong> „Çø„ÉÉ„Éó/„Çπ„Éö„Éº„Çπ „Åß„Ç∏„É£„É≥„Éó<br><strong>ÈÄ£Á∂ö„Çø„ÉÉ„Éó„ÅßÂ§öÊÆµ„Ç∏„É£„É≥„ÉóÔºÅÔºàÊúÄÂ§ß3ÊÆµÔºâ</strong><br><div class="score-info"><span>üçÜËåÑÂ≠ê +1</span><span>üóªÂØåÂ£´ +3</span><span>ü¶ÖÈ∑π +5 (3ÊÆµ„Ç∏„É£„É≥„Éó)</span></div></div>
        </div>
        <div class="overlay hidden" id="gameOverOverlay">
            <div class="emoji">üí•</div>
            <h1>„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº</h1>
            <p>„Çπ„Ç≥„Ç¢: <span id="final-score">0</span></p>
            <p>„Éè„Ç§„Çπ„Ç≥„Ç¢: <span id="final-high-score">0</span></p>
            <p id="obstacle-stats" style="font-size:12px;"></p>
            <button class="start-btn" onclick="startGame()">„ÇÇ„ÅÜ‰∏ÄÂ∫¶</button>
            <div class="share-section"><a class="share-btn" id="lineShareBtn" href="#" target="_blank"><svg viewBox="0 0 24 24" fill="currentColor"><path d="M19.365 9.863c.349 0 .63.285.63.631 0 .345-.281.63-.63.63H17.61v1.125h1.755c.349 0 .63.283.63.63 0 .344-.281.629-.63.629h-2.386c-.345 0-.627-.285-.627-.629V8.108c0-.345.282-.63.63-.63h2.386c.349 0 .63.285.63.63 0 .349-.281.63-.63.63H17.61v1.125h1.755zm-3.855 3.016c0 .27-.174.51-.432.596-.064.021-.133.031-.199.031-.211 0-.391-.09-.51-.25l-2.443-3.317v2.94c0 .344-.279.629-.631.629-.346 0-.626-.285-.626-.629V8.108c0-.27.173-.51.43-.595.06-.023.136-.033.194-.033.195 0 .375.104.495.254l2.462 3.33V8.108c0-.345.282-.63.63-.63.345 0 .63.285.63.63v4.771zm-5.741 0c0 .344-.282.629-.631.629-.345 0-.627-.285-.627-.629V8.108c0-.345.282-.63.63-.63.346 0 .628.285.628.63v4.771zm-2.466.629H4.917c-.345 0-.63-.285-.63-.629V8.108c0-.345.285-.63.63-.63.348 0 .63.285.63.63v4.141h1.756c.348 0 .629.283.629.63 0 .344-.282.629-.629.629M24 10.314C24 4.943 18.615.572 12 .572S0 4.943 0 10.314c0 4.811 4.27 8.842 10.035 9.608.391.082.923.258 1.058.59.12.301.079.766.038 1.08l-.164 1.02c-.045.301-.24 1.186 1.049.645 1.291-.539 6.916-4.078 9.436-6.975C23.176 14.393 24 12.458 24 10.314"/></svg>LINE„Åß„Ç∑„Çß„Ç¢</a></div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let W, H, refSize, groundY = 0;
        let gameRunning = false, score = 0, highScore = localStorage.getItem('horseGameHighScore') || 0;
        let gameSpeed = 3, baseSpeed = 3, animationId, frameCount = 0;
        let fujiCount = 0, hawkCount = 0, eggplantCount = 0;
        document.getElementById('high-score').textContent = highScore;
        const horse = { x: 0, y: 0, width: 0, height: 0, velocityY: 0, gravity: 0, jumpForce: 0, isJumping: false, jumpCount: 0, maxJumps: 3, groundY: 0, legPhase: 0 };
        let obstacles = [], clouds = [];
        const OBSTACLE_SIZES = { EGGPLANT: { width: 0.035, height: 0.05 }, FUJI: { width: 0.16, height: 0.18 }, HAWK: { width: 0.10, height: 0.05 } };
        const OBSTACLE_TYPES = { EGGPLANT: { type: 'eggplant', score: 1, minSpeed: 0 }, FUJI: { type: 'fuji', score: 3, minSpeed: 0 }, HAWK: { type: 'hawk', score: 5, minSpeed: 4 } };

        function setupDimensions() {
            W = window.innerWidth; H = window.innerHeight;
            canvas.width = W; canvas.height = H;
            groundY = H * 0.85; refSize = Math.min(W, H);
            horse.width = refSize * 0.15; horse.height = horse.width * 0.75;
            horse.x = W * 0.08; horse.groundY = groundY - horse.height - 5;
            if (!horse.isJumping) horse.y = horse.groundY;
            horse.gravity = H * 0.0012; horse.jumpForce = -H * 0.020;
            baseSpeed = Math.max(2, W * 0.003);
            clouds = [];
            for (let i = 0; i < 5; i++) clouds.push({ x: W * (i / 5) + Math.random() * (W * 0.15), y: H * (0.08 + Math.random() * 0.15), size: refSize * (0.03 + Math.random() * 0.02) });
        }

        function drawHorse() {
            const x = horse.x, y = horse.y, s = horse.height / 60;
            ctx.save(); ctx.fillStyle = '#8B4513';
            ctx.beginPath(); ctx.ellipse(x + 40*s, y + 25*s, 35*s, 20*s, 0, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(x + 75*s, y + 5*s, 18*s, 12*s, -0.3, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.moveTo(x + 60*s, y + 10*s); ctx.quadraticCurveTo(x + 70*s, y + 20*s, x + 65*s, y + 30*s); ctx.lineTo(x + 55*s, y + 25*s); ctx.quadraticCurveTo(x + 55*s, y + 15*s, x + 60*s, y + 10*s); ctx.fill();
            ctx.beginPath(); ctx.moveTo(x + 80*s, y - 5*s); ctx.lineTo(x + 85*s, y - 15*s); ctx.lineTo(x + 90*s, y - 3*s); ctx.fill();
            ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(x + 82*s, y + 3*s, 3*s, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#4a2c0a'; ctx.beginPath(); ctx.moveTo(x + 55*s, y); ctx.quadraticCurveTo(x + 45*s, y - 10*s, x + 50*s, y + 5*s); ctx.quadraticCurveTo(x + 40*s, y - 5*s, x + 45*s, y + 10*s); ctx.quadraticCurveTo(x + 35*s, y, x + 40*s, y + 15*s); ctx.lineTo(x + 55*s, y + 15*s); ctx.fill();
            ctx.fillStyle = '#8B4513'; const lo = horse.isJumping ? 0 : Math.sin(horse.legPhase) * 8 * s;
            ctx.fillRect(x + 55*s, y + 35*s, 8*s, 25*s + lo); ctx.fillRect(x + 65*s, y + 35*s, 8*s, 25*s - lo); ctx.fillRect(x + 15*s, y + 35*s, 8*s, 25*s - lo); ctx.fillRect(x + 25*s, y + 35*s, 8*s, 25*s + lo);
            ctx.fillStyle = '#2d1b0e'; ctx.fillRect(x + 54*s, y + 58*s + lo, 10*s, 5*s); ctx.fillRect(x + 64*s, y + 58*s - lo, 10*s, 5*s); ctx.fillRect(x + 14*s, y + 58*s - lo, 10*s, 5*s); ctx.fillRect(x + 24*s, y + 58*s + lo, 10*s, 5*s);
            ctx.fillStyle = '#4a2c0a'; ctx.beginPath(); ctx.moveTo(x + 5*s, y + 20*s); ctx.quadraticCurveTo(x - 15*s, y + 35*s, x - 10*s, y + 50*s); ctx.quadraticCurveTo(x - 5*s, y + 45*s, x + 5*s, y + 35*s); ctx.fill();
            ctx.restore();
        }

        function drawFuji(obs) {
            const x = obs.x, h = obs.height, w = obs.width;
            ctx.save(); ctx.fillStyle = '#3d4654';
            ctx.beginPath(); ctx.moveTo(x - w * 0.08, groundY); ctx.lineTo(x + w / 2, groundY - h); ctx.lineTo(x + w * 1.08, groundY); ctx.closePath(); ctx.fill();
            ctx.fillStyle = '#4a5568'; ctx.beginPath(); ctx.moveTo(x, groundY); ctx.lineTo(x + w / 2, groundY - h); ctx.lineTo(x + w, groundY); ctx.closePath(); ctx.fill();
            ctx.fillStyle = '#FFF'; const sh = h * 0.4, sw = w * 0.5;
            ctx.beginPath(); ctx.moveTo(x + w/2 - sw/2, groundY - h + sh); ctx.lineTo(x + w/2, groundY - h); ctx.lineTo(x + w/2 + sw/2, groundY - h + sh); ctx.lineTo(x + w/2 + sw/3, groundY - h + sh + h * 0.08); ctx.lineTo(x + w/2, groundY - h + sh + h * 0.12); ctx.lineTo(x + w/2 - sw/3, groundY - h + sh + h * 0.08); ctx.closePath(); ctx.fill();
            ctx.fillStyle = 'rgba(0,0,0,0.15)'; ctx.beginPath(); ctx.moveTo(x + w/2, groundY - h); ctx.lineTo(x + w, groundY); ctx.lineTo(x + w/2, groundY); ctx.closePath(); ctx.fill();
            ctx.restore();
        }

        function drawHawk(obs) {
            const x = obs.x, y = obs.y, sz = obs.width, wp = Math.sin(frameCount * 0.12) * 0.4;
            ctx.save(); ctx.translate(x + sz/2, y);
            ctx.fillStyle = '#5D4037'; ctx.beginPath(); ctx.ellipse(0, 0, sz * 0.45, sz * 0.18, 0, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(sz * 0.4, -sz * 0.05, sz * 0.14, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#FF8C00'; ctx.beginPath(); ctx.moveTo(sz * 0.54, -sz * 0.05); ctx.lineTo(sz * 0.68, 0); ctx.lineTo(sz * 0.54, sz * 0.03); ctx.closePath(); ctx.fill();
            ctx.fillStyle = '#FFF'; ctx.beginPath(); ctx.arc(sz * 0.44, -sz * 0.08, sz * 0.05, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(sz * 0.45, -sz * 0.08, sz * 0.025, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#6D4C41';
            ctx.beginPath(); ctx.moveTo(-sz * 0.15, -sz * 0.05); ctx.quadraticCurveTo(-sz * 0.5, -sz * (0.5 + wp), -sz * 0.6, -sz * 0.15); ctx.quadraticCurveTo(-sz * 0.35, sz * 0.05, -sz * 0.15, -sz * 0.05); ctx.fill();
            ctx.beginPath(); ctx.moveTo(-sz * 0.15, sz * 0.05); ctx.quadraticCurveTo(-sz * 0.5, sz * (0.5 + wp), -sz * 0.6, sz * 0.15); ctx.quadraticCurveTo(-sz * 0.35, -sz * 0.05, -sz * 0.15, sz * 0.05); ctx.fill();
            ctx.fillStyle = '#4E342E'; ctx.beginPath(); ctx.moveTo(-sz * 0.4, 0); ctx.lineTo(-sz * 0.7, -sz * 0.12); ctx.lineTo(-sz * 0.65, 0); ctx.lineTo(-sz * 0.7, sz * 0.12); ctx.closePath(); ctx.fill();
            ctx.restore();
        }

        // Eggplant emoji style üçÜ
        function drawEggplant(obs) {
            const x = obs.x, h = obs.height, w = obs.width, cx = x + w / 2;
            ctx.save();
            
            // Main body - tilted egg shape like emoji
            const bodyTop = groundY - h * 0.85;
            const bodyBottom = groundY - h * 0.05;
            
            // Purple gradient
            const g = ctx.createLinearGradient(x - w * 0.2, bodyTop, x + w * 1.2, bodyBottom);
            g.addColorStop(0, '#5B2C6F');
            g.addColorStop(0.3, '#7D3C98');
            g.addColorStop(0.5, '#8E44AD');
            g.addColorStop(0.7, '#7D3C98');
            g.addColorStop(1, '#4A235A');
            
            ctx.fillStyle = g;
            ctx.beginPath();
            // Tilted oval/egg shape - fatter at bottom, narrower at top
            ctx.moveTo(cx, bodyBottom);
            // Right side - bulge out
            ctx.bezierCurveTo(
                x + w * 1.3, bodyBottom - h * 0.15,
                x + w * 1.1, bodyTop + h * 0.3,
                cx + w * 0.15, bodyTop
            );
            // Left side - curve back
            ctx.bezierCurveTo(
                x - w * 0.1, bodyTop + h * 0.3,
                x - w * 0.3, bodyBottom - h * 0.15,
                cx, bodyBottom
            );
            ctx.fill();
            
            // Highlight - glossy shine
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath();
            ctx.ellipse(cx - w * 0.15, groundY - h * 0.5, w * 0.15, h * 0.22, -0.3, 0, Math.PI * 2);
            ctx.fill();
            
            // Green calyx/stem cap
            ctx.fillStyle = '#1E8449';
            const stemY = bodyTop - h * 0.02;
            
            // Star-shaped calyx
            ctx.beginPath();
            ctx.moveTo(cx + w * 0.15, stemY + h * 0.08);
            ctx.quadraticCurveTo(cx + w * 0.35, stemY - h * 0.05, cx + w * 0.25, stemY - h * 0.12);
            ctx.quadraticCurveTo(cx + w * 0.1, stemY + h * 0.02, cx, stemY - h * 0.05);
            ctx.quadraticCurveTo(cx - w * 0.1, stemY + h * 0.02, cx - w * 0.25, stemY - h * 0.12);
            ctx.quadraticCurveTo(cx - w * 0.35, stemY - h * 0.05, cx - w * 0.15, stemY + h * 0.08);
            ctx.quadraticCurveTo(cx, stemY + h * 0.12, cx + w * 0.15, stemY + h * 0.08);
            ctx.fill();
            
            // Stem
            ctx.fillStyle = '#145A32';
            ctx.beginPath();
            ctx.moveTo(cx - w * 0.06, stemY - h * 0.02);
            ctx.lineTo(cx - w * 0.04, stemY - h * 0.18);
            ctx.lineTo(cx + w * 0.04, stemY - h * 0.18);
            ctx.lineTo(cx + w * 0.06, stemY - h * 0.02);
            ctx.fill();
            
            ctx.restore();
        }

        function drawObstacle(obs) { if (obs.type === 'fuji') drawFuji(obs); else if (obs.type === 'hawk') drawHawk(obs); else drawEggplant(obs); }
        function drawClouds() { ctx.fillStyle = 'rgba(255,255,255,0.8)'; clouds.forEach(c => { ctx.beginPath(); ctx.arc(c.x, c.y, c.size, 0, Math.PI * 2); ctx.arc(c.x + c.size * 0.8, c.y - c.size * 0.2, c.size * 0.7, 0, Math.PI * 2); ctx.arc(c.x + c.size * 1.5, c.y, c.size * 0.8, 0, Math.PI * 2); ctx.fill(); }); }
        function drawBackgroundFuji() { ctx.save(); ctx.globalAlpha = 0.25; const fw = W * 0.35, fh = H * 0.5, fx = W * 0.55; ctx.fillStyle = '#6b7280'; ctx.beginPath(); ctx.moveTo(fx, groundY); ctx.lineTo(fx + fw/2, groundY - fh); ctx.lineTo(fx + fw, groundY); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#FFF'; const sh = fh * 0.28; ctx.beginPath(); ctx.moveTo(fx + fw * 0.32, groundY - fh + sh); ctx.lineTo(fx + fw/2, groundY - fh); ctx.lineTo(fx + fw * 0.68, groundY - fh + sh); ctx.closePath(); ctx.fill(); ctx.restore(); }
        function drawGround() { ctx.fillStyle = '#228B22'; ctx.fillRect(0, groundY, W, H - groundY); ctx.strokeStyle = '#1a6b1a'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0, groundY); ctx.lineTo(W, groundY); ctx.stroke(); }
        function drawSky() { const g = ctx.createLinearGradient(0, 0, 0, groundY); g.addColorStop(0, '#87CEEB'); g.addColorStop(0.7, '#B0E0E6'); g.addColorStop(1, '#98D8C8'); ctx.fillStyle = g; ctx.fillRect(0, 0, W, groundY); }

        function chooseObstacleType() { const t = [OBSTACLE_TYPES.EGGPLANT, OBSTACLE_TYPES.FUJI]; if (gameSpeed >= OBSTACLE_TYPES.HAWK.minSpeed) t.push(OBSTACLE_TYPES.HAWK); const wt = t.map(x => 1 / x.score), tot = wt.reduce((a, b) => a + b, 0); let r = Math.random() * tot; for (let i = 0; i < t.length; i++) { r -= wt[i]; if (r <= 0) return t[i]; } return t[0]; }
        function createObstacle() { const ti = chooseObstacleType(), obs = { type: ti.type, score: ti.score, x: W + 20, passed: false }; if (ti.type === 'fuji') { obs.width = refSize * OBSTACLE_SIZES.FUJI.width; obs.height = refSize * OBSTACLE_SIZES.FUJI.height; } else if (ti.type === 'hawk') { obs.width = refSize * OBSTACLE_SIZES.HAWK.width; obs.height = refSize * OBSTACLE_SIZES.HAWK.height; const sjh = (horse.jumpForce * horse.jumpForce) / (2 * horse.gravity); obs.y = horse.groundY - sjh * 1.3; } else { obs.width = refSize * OBSTACLE_SIZES.EGGPLANT.width; obs.height = refSize * OBSTACLE_SIZES.EGGPLANT.height; } return obs; }

        function update() {
            frameCount++;
            if (horse.isJumping || horse.y < horse.groundY) { horse.velocityY += horse.gravity; horse.y += horse.velocityY; if (horse.y >= horse.groundY) { horse.y = horse.groundY; horse.velocityY = 0; horse.isJumping = false; horse.jumpCount = 0; } }
            if (!horse.isJumping) horse.legPhase += 0.25;
            obstacles.forEach(obs => { obs.x -= gameSpeed; if (!obs.passed && obs.x + obs.width < horse.x) { obs.passed = true; score += obs.score; if (obs.type === 'fuji') fujiCount++; else if (obs.type === 'hawk') hawkCount++; else eggplantCount++; } });
            obstacles = obstacles.filter(obs => obs.x + obs.width > -50);
            const minGap = Math.max(W * 0.28, W * 0.45 - gameSpeed * W * 0.02), maxGap = Math.max(W * 0.45, W * 0.7 - gameSpeed * W * 0.025);
            const last = obstacles[obstacles.length - 1]; if (!last || last.x < W - minGap - Math.random() * (maxGap - minGap)) obstacles.push(createObstacle());
            clouds.forEach(c => { c.x -= gameSpeed * 0.15; if (c.x + c.size * 2 < 0) c.x = W + c.size; });
            const hb = { x: horse.x + horse.width * 0.2, y: horse.y + horse.height * 0.15, w: horse.width * 0.5, h: horse.height * 0.6 };
            for (const obs of obstacles) { let ob; if (obs.type === 'hawk') ob = { x: obs.x + obs.width * 0.1, y: obs.y - obs.height * 0.4, w: obs.width * 0.8, h: obs.height * 0.8 }; else if (obs.type === 'eggplant') ob = { x: obs.x, y: groundY - obs.height + obs.height * 0.3, w: obs.width, h: obs.height * 0.6 }; else ob = { x: obs.x + obs.width * 0.15, y: groundY - obs.height, w: obs.width * 0.7, h: obs.height }; if (hb.x < ob.x + ob.w && hb.x + hb.w > ob.x && hb.y < ob.y + ob.h && hb.y + hb.h > ob.y) { gameOver(); return; } }
            document.getElementById('current-score').textContent = score;
            const maxSpd = baseSpeed * 2.8; if (frameCount % 350 === 0 && gameSpeed < maxSpd) gameSpeed += baseSpeed * 0.06;
        }

        function draw() { drawSky(); drawBackgroundFuji(); drawClouds(); drawGround(); obstacles.forEach(obs => drawObstacle(obs)); drawHorse(); }
        function gameLoop() { if (!gameRunning) return; update(); draw(); animationId = requestAnimationFrame(gameLoop); }
        
        // Triple jump support
        function jump() {
            if (!horse.isJumping && horse.y >= horse.groundY - 5) {
                // First jump from ground
                horse.isJumping = true;
                horse.velocityY = horse.jumpForce;
                horse.jumpCount = 1;
            } else if (horse.isJumping && horse.jumpCount < horse.maxJumps) {
                // Additional jumps in air (2nd or 3rd)
                horse.velocityY = horse.jumpForce;
                horse.jumpCount++;
            }
        }
        
        function startGame() { setupDimensions(); gameRunning = true; score = 0; frameCount = 0; fujiCount = 0; hawkCount = 0; eggplantCount = 0; gameSpeed = baseSpeed; obstacles = []; horse.y = horse.groundY; horse.velocityY = 0; horse.isJumping = false; horse.jumpCount = 0; document.getElementById('startOverlay').classList.add('hidden'); document.getElementById('gameOverOverlay').classList.add('hidden'); gameLoop(); }
        function gameOver() { gameRunning = false; cancelAnimationFrame(animationId); if (score > highScore) { highScore = score; localStorage.setItem('horseGameHighScore', highScore); } document.getElementById('high-score').textContent = highScore; document.getElementById('final-score').textContent = score; document.getElementById('final-high-score').textContent = highScore; document.getElementById('obstacle-stats').textContent = 'üçÜ' + eggplantCount + ' üóª' + fujiCount + ' ü¶Ö' + hawkCount; document.getElementById('gameOverOverlay').classList.remove('hidden'); const st = 'üê¥È¶¨„Ç∏„É£„É≥„Éó„Ç≤„Éº„É†\n„Çπ„Ç≥„Ç¢: ' + score + 'ÁÇπÔºÅ\nüçÜ' + eggplantCount + ' üóª' + fujiCount + ' ü¶Ö' + hawkCount + '\n'; document.getElementById('lineShareBtn').href = 'https://social-plugins.line.me/lineit/share?url=' + encodeURIComponent(window.location.href) + '&text=' + encodeURIComponent(st); }
        function toggleFullscreen() { const el = document.documentElement; if (!document.fullscreenElement) { if (el.requestFullscreen) el.requestFullscreen(); else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen(); } else { if (document.exitFullscreen) document.exitFullscreen(); else if (document.webkitExitFullscreen) document.webkitExitFullscreen(); } }

        window.addEventListener('resize', () => { setupDimensions(); if (!gameRunning) draw(); });
        window.addEventListener('orientationchange', () => { setTimeout(() => { setupDimensions(); if (!gameRunning) draw(); }, 150); });
        document.addEventListener('fullscreenchange', () => { setTimeout(() => { setupDimensions(); if (!gameRunning) draw(); }, 100); });
        document.addEventListener('keydown', (e) => { if (e.code === 'Space' || e.code === 'ArrowUp') { e.preventDefault(); if (gameRunning) jump(); } });
        canvas.addEventListener('click', () => { if (gameRunning) jump(); });
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); if (gameRunning) jump(); }, { passive: false });
        document.addEventListener('contextmenu', (e) => e.preventDefault());

        setupDimensions(); draw();
    </script>
</body>
</html>
